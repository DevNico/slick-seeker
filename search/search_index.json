{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Slick Seeker","text":"<p>Type-safe, high-performance cursor-based pagination for Slick 3.5+.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Keyset Pagination - O(1) performance regardless of page depth</li> <li>Bidirectional - Navigate forward and backward through result sets</li> <li>Type-Safe - Compile-time verification of cursor/column matching</li> <li>PostgreSQL Tuple Optimization - Compile-time safe tuple comparisons for PostgreSQL (NEW!)</li> <li>Profile Agnostic - Works with any Slick JDBC profile (PostgreSQL, MySQL, H2, SQLite, Oracle, etc.)</li> <li>Flexible Ordering - Support for nulls first/last, custom enum orders</li> <li>Modular - Core + optional Play JSON integration</li> <li>Composable - Chain decorators for Base64, compression, encryption</li> </ul>"},{"location":"#why-cursor-based-pagination","title":"Why Cursor-Based Pagination?","text":"<p>Traditional offset-based pagination (<code>OFFSET</code> + <code>LIMIT</code>) has serious performance issues:</p> <pre><code>-- Page 1000: Database must scan and skip 19,900 rows!\nSELECT * FROM users ORDER BY name LIMIT 100 OFFSET 19900;\n</code></pre> <p>Problems:</p> <ul> <li>Slow for deep pages (O(n) where n = offset)</li> <li>Unstable with concurrent writes (items shift between pages)</li> <li>Memory intensive for large offsets</li> </ul> <p>Cursor-based pagination (keyset pagination) solves this:</p> <pre><code>-- Any page: Fast index-based lookup!\nSELECT * FROM users\nWHERE name &gt; 'last_name' OR (name = 'last_name' AND id &gt; last_id)\nORDER BY name, id \nLIMIT 100;\n</code></pre> <p>Benefits:</p> <ul> <li>Constant O(1) performance for any page</li> <li>Stable with concurrent writes</li> <li>Efficient index usage</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Add to your <code>build.sbt</code>:</p> <pre><code>libraryDependencies ++= Seq(\n  \"io.github.devnico\" %% \"slick-seeker\" % \"0.4.0\",\n  \"io.github.devnico\" %% \"slick-seeker-play-json\" % \"0.4.0\"  // Optional, but you need some kind of cursor encoder\n)\n</code></pre>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>// Step 1: Create a custom profile\nimport slick.jdbc.PostgresProfile\nimport io.github.devnico.slickseeker.SlickSeekerSupport\nimport io.github.devnico.slickseeker.playjson.PlayJsonSeekerSupport\n\ntrait MyPostgresProfile extends PostgresProfile \n  with SlickSeekerSupport \n  with PlayJsonSeekerSupport {\n\n  object MyApi extends API with SeekImplicits with JsonSeekerImplicits\n  override val api: MyApi.type = MyApi\n}\n\nobject MyPostgresProfile extends MyPostgresProfile\n\n// Step 2: Import your profile API\nimport MyPostgresProfile.api._\n\n// Step 3: Define your table\ncase class User(id: Int, name: String, email: String)\n\nclass Users(tag: Tag) extends Table[User](tag, \"users\") {\n  def id = column[Int](\"id\", O.PrimaryKey, O.AutoInc)\n  def name = column[String](\"name\")\n  def email = column[String](\"email\")\n  def * = (id, name, email).mapTo[User]\n}\n\nval users = TableQuery[Users]\n\n// Create a seeker\nval seeker = users.toSeeker\n  .seek(_.name.asc)      // Primary sort\n  .seek(_.id.asc)        // Tiebreaker\n\n// Paginate!\nval page1 = db.run(seeker.page(limit = 20, cursor = None))\n// PaginatedResult(total=100, items=[...], nextCursor=Some(\"...\"), prevCursor=None)\n\nval page2 = db.run(seeker.page(limit = 20, cursor = page1.nextCursor))\n// Continue pagination...\n</code></pre>"},{"location":"#learn-more","title":"Learn More","text":"<ul> <li>Quick Start - Get up and running in 5 minutes</li> <li>Core Concepts - Understand cursor pagination and decorators</li> <li>Cookbook - Real-world examples and patterns</li> </ul>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Scala 2.13.14+, 3.3.4+, 3.5.2+</li> <li>Slick 3.5.0+</li> <li>Your Slick profile API must be imported before slick-seeker</li> </ul>"},{"location":"#license","title":"License","text":"<p>Apache License 2.0 - Copyright \u00a9 2025 Nicolas Schlecker</p>"},{"location":"concepts/","title":"Core Concepts","text":""},{"location":"concepts/#cursor-based-pagination","title":"Cursor-Based Pagination","text":"<p>Slick Seeker implements keyset pagination, which uses the values from the last row as a cursor to find the next page.</p>"},{"location":"concepts/#how-it-works","title":"How It Works","text":"<p>Instead of using <code>OFFSET</code>:</p> <pre><code>-- Slow for deep pages\nSELECT * FROM users ORDER BY name LIMIT 20 OFFSET 1000;\n</code></pre> <p>We use the last row's values:</p> <pre><code>-- Fast for any page\nSELECT * FROM users \nWHERE name &gt; 'last_name' OR (name = 'last_name' AND id &gt; last_id)\nORDER BY name, id \nLIMIT 20;\n</code></pre>"},{"location":"concepts/#seek","title":"seek()","text":"<p>Use <code>seek()</code> for direct column references.</p> <pre><code>// Direct columns - automatic extraction\nval seeker = users.toSeeker\n  .seek(_.name.asc)\n  .seek(_.id.asc)\n</code></pre> <p>Works with:</p> <ul> <li>Table columns: <code>_.name</code>, <code>_.email</code></li> <li>Tuple fields: <code>_._1</code>, <code>_._2</code></li> <li>Nested tuples: <code>_._1._2</code></li> <li>Any computed column: <code>_.name.toLowerCase</code></li> </ul> <p>The SQL looks like:</p> <pre><code>SELECT t.*, t.name, t.id  -- Cursor columns added automatically\nFROM users t\nWHERE t.name &gt; ? OR (t.name = ? AND t.id &gt; ?)\nORDER BY t.name ASC, t.id ASC\nLIMIT 20\n</code></pre>"},{"location":"concepts/#null-handling","title":"Null Handling","text":"<p>Slick Seeker supports explicit null ordering:</p> <pre><code>// Nulls last (default for ASC)\n.seek(_.lastName.asc)\n.seek(_.lastName.nullsLast.asc)  // Explicit\n\n// Nulls first\n.seek(_.lastName.nullsFirst.asc)\n</code></pre> <p>Direction affects default null ordering:</p> <pre><code>// ASC: nulls last by default\n.seek(_.lastName)\n.seekDirection(SortDirection.Asc)\n\n// DESC: nulls first by default\n.seek(_.lastName)\n.seekDirection(SortDirection.Desc)\n</code></pre>"},{"location":"concepts/#complex-null-handling","title":"Complex Null Handling","text":"<pre><code>case class Person(\n  id: Int,\n  firstName: String,\n  middleName: Option[String],\n  lastName: Option[String]\n)\n\n// Sort: lastName (nulls last), middleName (nulls first), firstName, id\nval seeker = persons.toSeeker\n  .seek(_.lastName.nullsLast.asc)\n  .seek(_.middleName.nullsFirst.asc)\n  .seek(_.firstName.asc)\n  .seek(_.id.asc)\n</code></pre>"},{"location":"concepts/#custom-sort-orders-enumsadts","title":"Custom Sort Orders (Enums/ADTs)","text":"<p>For enums or sealed traits, define a custom sort order:</p> Scala 3Scala 2 <pre><code>enum Status {\n  case Pending, Active, Completed, Archived\n}\n\n// Define the order\ngiven SeekOrder[Status] = SeekOrder(IndexedSeq(\n  Status.Pending,\n  Status.Active,\n  Status.Completed,\n  Status.Archived\n))\n\n// Use it\nval seeker = tasks.toSeeker\n  .seek(_.status.asc)  // Uses custom order\n  .seek(_.id.asc)\n</code></pre> <pre><code>sealed trait Status\nobject Status {\n  case object Pending extends Status\n  case object Active extends Status\n  case object Completed extends Status\n  case object Archived extends Status\n}\n\n// Define the order\nimplicit val statusOrder: SeekOrder[Status] = SeekOrder(IndexedSeq(\n  Status.Pending,\n  Status.Active,\n  Status.Completed,\n  Status.Archived\n))\n\n// Use it\nval seeker = tasks.toSeeker\n  .seek(_.status.asc)  // Uses custom order\n  .seek(_.id.asc)\n</code></pre> <p>This converts enum values to integers in SQL:</p> <pre><code>ORDER BY \n  CASE \n    WHEN status = 'Pending' THEN 0\n    WHEN status = 'Active' THEN 1\n    WHEN status = 'Completed' THEN 2\n    WHEN status = 'Archived' THEN 3\n  END ASC\n</code></pre>"},{"location":"concepts/#bidirectional-pagination","title":"Bidirectional Pagination","text":"<p>Slick Seeker supports both forward and backward navigation:</p> <pre><code>// Forward\nval page2 = seeker.page(limit = 20, cursor = page1.nextCursor)\n\n// Backward\nval backToPage1 = seeker.page(limit = 20, cursor = page2.prevCursor)\n</code></pre>"},{"location":"concepts/#how-it-works_1","title":"How It Works","text":"<p>Cursors encode direction:</p> <ul> <li>Forward: <code>&gt;</code> prefix</li> <li>Backward: <code>&lt;</code> prefix</li> </ul> <p>For backward pagination:</p> <ol> <li>Sort order is reversed</li> <li>Results are retrieved</li> <li>Results are reversed back to original order</li> </ol> <p>This ensures consistent ordering regardless of direction.</p>"},{"location":"concepts/#cursor-environment","title":"Cursor Environment","text":"<p>The cursor environment controls how cursors are encoded. Define it inside your profile:</p> <pre><code>import io.github.devnico.slickseeker.playjson.PlayJsonSeekerSupport\n\ntrait MyPostgresProfile extends PostgresProfile \n  with SlickSeekerSupport \n  with PlayJsonSeekerSupport {\n  object MyApi extends API with SeekImplicits with JsonSeekerImplicits\n  override val api: MyApi.type = MyApi\n}\n</code></pre> <p>Components:</p> <ul> <li>Codec: Serializes values (e.g., JSON)</li> <li>Decorator: Transforms final string (e.g., Base64)</li> </ul>"},{"location":"concepts/#decorators","title":"Decorators","text":"<p>Decorators transform cursor strings. Chain them for multiple transformations:</p> <pre><code>trait MyProfile extends PostgresProfile \n  with SlickSeekerSupport \n  with PlayJsonSeekerSupport {\n\n  object MyApi extends API with SeekImplicits with JsonSeekerImplicits {\n    // Override with custom decorator\n    override implicit val cursorEnvironment: CursorEnvironment[JsValue] = \n      CursorEnvironment(jsonCursorCodec, IdentityDecorator())\n  }\n\n  override val api: MyApi.type = MyApi\n}\n</code></pre>"},{"location":"concepts/#custom-decorator","title":"Custom Decorator","text":"<pre><code>class HexDecorator(inner: CursorDecorator = IdentityDecorator()) \n  extends CursorDecorator {\n\n  override def encode(value: String): String = {\n    val innerEncoded = inner.encode(value)\n    innerEncoded.getBytes.map(\"%02x\".format(_)).mkString\n  }\n\n  override def decode(cursor: String): Either[Throwable, String] = {\n    Try {\n      val bytes = cursor.grouped(2).map(Integer.parseInt(_, 16).toByte).toArray\n      new String(bytes)\n    }.toEither.flatMap(inner.decode)\n  }\n}\n\n// Use it\ntrait MyProfile extends PostgresProfile \n  with SlickSeekerSupport \n  with PlayJsonSeekerSupport {\n\n  object MyApi extends API with SeekImplicits with JsonSeekerImplicits {\n    override implicit val cursorEnvironment: CursorEnvironment[JsValue] =\n      CursorEnvironment(jsonCursorCodec, Base64Decorator(HexDecorator()))\n  }\n\n  override val api: MyApi.type = MyApi\n}\n</code></pre> <p>Decorators are useful for:</p> <ul> <li>Base64 - URL-safe encoding</li> <li>Compression - Reduce cursor size</li> <li>Encryption - Hide cursor content</li> <li>Signing - Prevent tampering</li> </ul>"},{"location":"concepts/#tips","title":"Tips","text":""},{"location":"concepts/#1-always-include-a-unique-column","title":"1. Always Include a Unique Column","text":"<pre><code>// BAD: Non-unique sort can miss/duplicate items\n.seek(_.status)\n\n// GOOD: Include unique tiebreaker\n.seek(_.status)\n.seek(_.id)\n</code></pre>"},{"location":"concepts/#2-create-composite-indexes","title":"2. Create Composite Indexes","text":"<pre><code>-- Match your seek columns\nCREATE INDEX idx_users_name_id ON users(name, id);\nCREATE INDEX idx_tasks_status_priority_id ON tasks(status, priority, id);\n</code></pre>"},{"location":"concepts/#3-limit-sort-columns","title":"3. Limit Sort Columns","text":"<p>Each sort column adds to the WHERE clause complexity. Use 2-4 columns typically.</p>"},{"location":"cookbook/","title":"Cookbook","text":"<p>Real-world examples and patterns.</p>"},{"location":"cookbook/#rest-api-endpoint","title":"REST API Endpoint","text":"<pre><code>import io.github.devnico.slickseeker._\nimport play.api.mvc._\nimport play.api.libs.json._\n\n// Import your profile API\nimport MyPostgresProfile.api._\n\nclass UserController @Inject()(\n  cc: ControllerComponents,\n  db: Database\n)(implicit ec: ExecutionContext) extends AbstractController(cc) {\n\n  implicit val userFormat: Format[User] = Json.format[User]\n\n  def list(\n    cursor: Option[String],\n    limit: Option[Int],\n    sort: Option[String]\n  ): Action[AnyContent] = Action.async {\n    val seeker = sort match {\n      case Some(\"name\") =&gt; users.toSeeker.seek(_.name.asc).seek(_.id.asc)\n      case Some(\"email\") =&gt; users.toSeeker.seek(_.email.asc).seek(_.id.asc)\n      case _ =&gt; users.toSeeker.seek(_.id.asc)\n    }\n\n    db.run(seeker.page(limit.getOrElse(20), cursor, maxLimit = 100))\n      .map(result =&gt; Ok(Json.toJson(result)))\n  }\n}\n</code></pre>"},{"location":"cookbook/#filtering-with-pagination","title":"Filtering with Pagination","text":"<pre><code>def searchUsers(\n  nameFilter: Option[String],\n  activeOnly: Boolean,\n  cursor: Option[String],\n  limit: Int\n): Future[PaginatedResult[User]] = {\n\n  val baseQuery = users\n    .filterOpt(nameFilter)(_.name like _)\n    .filterIf(activeOnly)(_.active === true)\n\n  val seeker = baseQuery.toSeeker\n    .seek(_.name.asc)\n    .seek(_.id.asc)\n\n  db.run(seeker.page(limit, cursor))\n}\n</code></pre>"},{"location":"cookbook/#joined-tables","title":"Joined Tables","text":"<pre><code>case class Order(id: Int, userId: Int, total: Double, createdAt: Timestamp)\ncase class User(id: Int, name: String, email: String)\ncase class OrderWithUser(order: Order, userName: String)\n\nval ordersWithUsers = orders\n  .join(users).on(_.userId === _.id)\n  .map { case (o, u) =&gt; (o, u.name) }\n\nval seeker = ordersWithUsers.toSeeker\n  .seek(t =&gt; t._1.createdAt.desc)  // Order by order date\n  .seek(t =&gt; t._1.id.asc)          // Tiebreaker\n  .map { case (order, userName) =&gt; \n    OrderWithUser(order, userName)\n  }\n</code></pre>"},{"location":"cookbook/#aggregated-results","title":"Aggregated Results","text":"<pre><code>case class UserStats(userId: Int, orderCount: Int, totalSpent: Double)\n\nval userStats = orders\n  .groupBy(_.userId)\n  .map { case (userId, orders) =&gt;\n    (userId, orders.length, orders.map(_.total).sum)\n  }\n\nval seeker = userStats.toSeeker\n  .seek(_._3.desc)  // Sort by total spent\n  .seek(_._1.asc)   // Tiebreaker: user ID\n</code></pre>"},{"location":"cookbook/#complex-sorting","title":"Complex Sorting","text":""},{"location":"cookbook/#multi-level-priority","title":"Multi-Level Priority","text":"Scala 3Scala 2 <pre><code>enum Priority {\n  case Critical, High, Normal, Low\n}\n\nenum Status {\n  case Open, InProgress, Completed\n}\n\ngiven SeekOrder[Priority] = SeekOrder(IndexedSeq(\n  Priority.Critical, Priority.High, Priority.Normal, Priority.Low\n))\n\ngiven SeekOrder[Status] = SeekOrder(IndexedSeq(\n  Status.Open, Status.InProgress, Status.Completed\n))\n\ncase class Task(\n  id: Int,\n  title: String,\n  priority: Priority,\n  status: Status,\n  dueDate: Option[Timestamp]\n)\n\nval seeker = tasks.toSeeker\n  .seek(_.priority.asc)           // Critical first\n  .seek(_.status.asc)             // Open first\n  .seek(_.dueDate.nullsLast.asc)  // Due date (overdue first)\n  .seek(_.id.asc)                 // Tiebreaker\n</code></pre> <pre><code>sealed trait Priority\nobject Priority {\n  case object Critical extends Priority\n  case object High extends Priority\n  case object Normal extends Priority\n  case object Low extends Priority\n}\n\nsealed trait Status\nobject Status {\n  case object Open extends Status\n  case object InProgress extends Status\n  case object Completed extends Status\n}\n\nimplicit val priorityOrder: SeekOrder[Priority] = SeekOrder(IndexedSeq(\n  Priority.Critical, Priority.High, Priority.Normal, Priority.Low\n))\n\nimplicit val statusOrder: SeekOrder[Status] = SeekOrder(IndexedSeq(\n  Status.Open, Status.InProgress, Status.Completed\n))\n\ncase class Task(\n  id: Int,\n  title: String,\n  priority: Priority,\n  status: Status,\n  dueDate: Option[Timestamp]\n)\n\nval seeker = tasks.toSeeker\n  .seek(_.priority.asc)           // Critical first\n  .seek(_.status.asc)             // Open first\n  .seek(_.dueDate.nullsLast.asc)  // Due date (overdue first)\n  .seek(_.id.asc)                 // Tiebreaker\n</code></pre>"},{"location":"cookbook/#sorting-simplified","title":"Sorting Simplified","text":""},{"location":"cookbook/#basic-sorting","title":"Basic Sorting","text":"<pre><code>val seeker = persons.toSeeker\n  .seek(_.lastName.asc)\n  .seek(_.firstName.asc)\n  .seek(_.id.asc)\n</code></pre>"},{"location":"cookbook/#postgresql-tuple-optimization","title":"PostgreSQL Tuple Optimization","text":"<p>For PostgreSQL databases, use <code>SlickPgTupleSeeker</code> for type-safe, tuple-optimized pagination. This generates simpler SQL with compile-time safety guarantees.</p>"},{"location":"cookbook/#standard-approach-default","title":"Standard Approach (Default)","text":"<pre><code>val seeker = users.toSeeker\n  .seek(_.name.asc)\n  .seek(_.id.asc)\n</code></pre> <p>Generates SQL like: <pre><code>WHERE (name &gt; ?) OR (name = ? AND id &gt; ?)\nORDER BY name ASC, id ASC\n</code></pre></p>"},{"location":"cookbook/#postgresql-tuple-approach-type-safe","title":"PostgreSQL Tuple Approach (Type-Safe)","text":"<pre><code>val seeker = users.toPgTupleSeekerAsc  // Direction enforced at creation\n  .seek(_.name)    // No .asc needed - enforced by type\n  .seek(_.id)\n</code></pre> <p>Generates SQL like: <pre><code>WHERE (name, id) &gt; (?, ?)\nORDER BY name ASC, id ASC\n</code></pre></p>"},{"location":"cookbook/#when-to-use","title":"When to Use","text":"<ul> <li>Use <code>toPgTupleSeekerAsc</code> / <code>toPgTupleSeekerDesc</code> when:</li> <li>Your database is PostgreSQL 8.2+ or H2 in PostgreSQL mode</li> <li>You have multiple seek columns (2 or more)</li> <li>All seek columns are non-nullable (compile-time enforced)</li> <li>All seek columns have the SAME sort direction (compile-time enforced)</li> <li>Query performance is critical</li> <li> <p>You want maximum type safety</p> </li> <li> <p>Use standard <code>.toSeeker</code> when:</p> </li> <li>You need database portability (H2, MySQL, SQLite)</li> <li>You have only one seek column</li> <li>Any of your seek columns are nullable (<code>Option[T]</code>)</li> <li>You have mixed sort directions (e.g., <code>col1.asc, col2.desc</code>)</li> <li>You're unsure about database compatibility</li> </ul>"},{"location":"cookbook/#type-safety-guarantees","title":"Type Safety Guarantees","text":"<p><code>SlickPgTupleSeeker</code> enforces constraints at compile time:</p> <pre><code>// \u2705 CORRECT: All non-nullable, uniform direction\nval ascSeeker = users.toPgTupleSeekerAsc\n  .seek(_.name)   // String - OK\n  .seek(_.age)    // Int - OK\n  .seek(_.id)     // Int - OK\n\n// \u2705 CORRECT: All DESC\nval descSeeker = users.toPgTupleSeekerDesc\n  .seek(_.createdAt)  // Timestamp - OK\n  .seek(_.id)         // Int - OK\n\n// \u274c COMPILE ERROR: Nullable column\nval broken1 = users.toPgTupleSeekerAsc\n  .seek(_.name)\n  .seek(_.email)  // Option[String] \u2192 COMPILE ERROR!\n  .seek(_.id)\n// Error: No given instance of type slick.ast.BaseTypedType[Option[String]]\n\n// \u274c IMPOSSIBLE: Mixed directions (type system prevents it)\n// Once you choose Asc or Desc, ALL columns must be that direction\n</code></pre>"},{"location":"cookbook/#example-with-multiple-columns","title":"Example with Multiple Columns","text":"<pre><code>// All columns ASC\nval seeker = orders.toPgTupleSeekerAsc\n  .seek(_.status)\n  .seek(_.priority)\n  .seek(_.createdAt)\n  .seek(_.id)\n\n// Or all columns DESC\nval descSeeker = orders.toPgTupleSeekerDesc\n  .seek(_.createdAt)\n  .seek(_.priority)\n  .seek(_.status)\n  .seek(_.id)\n\nval page = db.run(seeker.page(limit = 50, cursor = None))\n</code></pre> <p>This generates: <pre><code>WHERE (status, priority, created_at, id) &gt; (?, ?, ?, ?)\nORDER BY status ASC, priority ASC, created_at ASC, id ASC\n</code></pre></p> <p>Important: All columns must have the same direction (all ASC or all DESC). For mixed directions, use the standard <code>SlickSeeker</code>.</p>"},{"location":"cookbook/#performance-benefits","title":"Performance Benefits","text":"<p>PostgreSQL tuple comparison offers measurable benefits:</p> <p>Query Complexity: - Standard: <code>O(n)</code> comparisons where <code>n</code> = number of columns - Tuple: <code>O(1)</code> single tuple comparison</p> <p>Example with 4 columns:</p> <p>Standard approach: <pre><code>WHERE (col1 &gt; ?) OR \n      (col1 = ? AND col2 &gt; ?) OR\n      (col1 = ? AND col2 = ? AND col3 &gt; ?) OR\n      (col1 = ? AND col2 = ? AND col3 = ? AND col4 &gt; ?)\n-- 10 comparisons, 4 parameters repeated\n</code></pre></p> <p>Tuple approach: <pre><code>WHERE (col1, col2, col3, col4) &gt; (?, ?, ?, ?)\n-- 1 comparison, 4 parameters\n</code></pre></p> <p>Benefits: - Simpler query plans (easier for PostgreSQL optimizer) - Better index utilization (composite index scanned as single key) - Cleaner logs and explain plans - Reduced parsing overhead</p>"},{"location":"cookbook/#complete-working-example","title":"Complete Working Example","text":"<pre><code>import slick.jdbc.PostgresProfile\nimport io.github.devnico.slickseeker._\nimport io.github.devnico.slickseeker.playjson._\n\n// 1. Setup profile\ntrait MyPostgresProfile extends PostgresProfile \n  with SlickSeekerSupport \n  with PlayJsonSeekerSupport {\n\n  object MyApi extends API with SeekImplicits with JsonSeekerImplicits\n  override val api: MyApi.type = MyApi\n}\n\nobject MyPostgresProfile extends MyPostgresProfile\n\n// 2. Import API\nimport MyPostgresProfile.api._\nimport scala.concurrent.ExecutionContext.Implicits.global\n\n// 3. Define schema\ncase class Product(\n  id: Int,\n  name: String,\n  category: String,\n  price: BigDecimal,\n  stock: Int\n)\n\nclass Products(tag: Tag) extends Table[Product](tag, \"products\") {\n  def id = column[Int](\"id\", O.PrimaryKey, O.AutoInc)\n  def name = column[String](\"name\")\n  def category = column[String](\"category\")\n  def price = column[BigDecimal](\"price\")\n  def stock = column[Int](\"stock\")\n  def * = (id, name, category, price, stock).mapTo[Product]\n}\n\nval products = TableQuery[Products]\n\n// 4. Create type-safe seeker\nval seeker = products.toPgTupleSeekerAsc\n  .seek(_.category)  // Group by category\n  .seek(_.price)     // Then by price\n  .seek(_.id)        // Tiebreaker\n\n// 5. Paginate\nval db = Database.forConfig(\"mydb\")\n\nval page1 = db.run(seeker.page(limit = 50, cursor = None))\n// PaginatedResult(total=1000, items=[...], nextCursor=Some(\"...\"))\n\nval page2 = page1.flatMap { p1 =&gt;\n  db.run(seeker.page(limit = 50, cursor = p1.nextCursor))\n}\n\n// 6. Reverse direction for descending sort\nval descSeeker = products.toPgTupleSeekerDesc\n  .seek(_.price)      // Most expensive first\n  .seek(_.category)   // Then by category\n  .seek(_.id)         // Tiebreaker\n\nval expensiveFirst = db.run(descSeeker.page(limit = 10, cursor = None))\n</code></pre>"},{"location":"cookbook/#migration-guide","title":"Migration Guide","text":"<p>If you're currently using <code>SlickSeeker</code> with uniform non-nullable columns on PostgreSQL:</p> <p>Before: <pre><code>val seeker = users.toSeeker\n  .seek(_.lastName.asc)\n  .seek(_.firstName.asc)\n  .seek(_.id.asc)\n</code></pre></p> <p>After (Type-Safe): <pre><code>val seeker = users.toPgTupleSeekerAsc\n  .seek(_.lastName)\n  .seek(_.firstName)\n  .seek(_.id)\n</code></pre></p> <p>Migration checklist: 1. \u2705 All columns non-nullable? (no <code>Option[T]</code>) 2. \u2705 All columns same direction? (all ASC or all DESC) 3. \u2705 Database is PostgreSQL 8.2+ or H2 in PostgreSQL mode? 4. \u2705 Want compile-time safety?</p> <p>If all yes \u2192 migrate to <code>toPgTupleSeekerAsc</code> / <code>toPgTupleSeekerDesc</code></p>"},{"location":"cookbook/#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"cookbook/#trying-to-mix-directions","title":"\u274c Trying to Mix Directions","text":"<pre><code>// This won't compile - direction fixed at seeker level\nval seeker = products.toPgTupleSeekerAsc\n  .seek(_.name)\n  // No way to make price DESC - type system prevents it!\n</code></pre> <p>Solution: Use standard <code>SlickSeeker</code> for mixed directions.</p>"},{"location":"cookbook/#using-nullable-columns","title":"\u274c Using Nullable Columns","text":"<pre><code>case class User(id: Int, name: String, email: Option[String])\n\n// This won't compile - email is Option[String]\nval seeker = users.toPgTupleSeekerAsc\n  .seek(_.name)\n  .seek(_.email)  // \u274c Error: No given instance of BaseTypedType[Option[String]]\n</code></pre> <p>Solution: Use standard <code>SlickSeeker</code> or filter out nulls beforehand: <pre><code>val activeUsers = users.filter(_.email.isDefined)\n// Still can't use PgTupleSeeker because email is still Option[String] type\n\n// Better: Use standard SlickSeeker with nulls handling\nval seeker = users.toSeeker\n  .seek(_.name.asc)\n  .seek(_.email.nullsLast.asc)\n  .seek(_.id.asc)\n</code></pre></p>"},{"location":"cookbook/#database-not-postgresql","title":"\u274c Database Not PostgreSQL","text":"<pre><code>// Using MySQL or SQLite?\nval seeker = users.toPgTupleSeekerAsc  // \u274c Will fail at runtime!\n  .seek(_.name)\n  .seek(_.id)\n\n// Runtime error: Syntax error in SQL\n// MySQL/SQLite don't support tuple comparison\n</code></pre> <p>Solution: Use standard <code>SlickSeeker</code> for database portability.</p>"},{"location":"cookbook/#best-practices","title":"Best Practices","text":"<p>1. Use PgTupleSeeker When: <pre><code>// \u2705 PostgreSQL, non-nullable columns, uniform direction\nval fastSeeker = orders.toPgTupleSeekerDesc\n  .seek(_.createdAt)  // Latest first\n  .seek(_.id)         // Tiebreaker\n</code></pre></p> <p>2. Use Standard SlickSeeker When: <pre><code>// \u2705 Need nullable handling\nval nullableSeeker = users.toSeeker\n  .seek(_.email.nullsLast.asc)\n  .seek(_.id.asc)\n\n// \u2705 Need mixed directions\nval mixedSeeker = products.toSeeker\n  .seek(_.featured.desc)     // Featured first\n  .seek(_.price.asc)         // Then cheapest\n  .seek(_.id.asc)            // Tiebreaker\n\n// \u2705 Need database portability\nval portableSeeker = items.toSeeker  // Works on MySQL, SQLite, H2, etc.\n  .seek(_.name.asc)\n  .seek(_.id.asc)\n</code></pre></p> <p>3. Always Include a Unique Tiebreaker: <pre><code>// \u2705 GOOD: id is unique\nval seeker = products.toPgTupleSeekerAsc\n  .seek(_.category)\n  .seek(_.price)\n  .seek(_.id)  // Ensures stable pagination\n\n// \u274c BAD: price might have duplicates\nval badSeeker = products.toPgTupleSeekerAsc\n  .seek(_.category)\n  .seek(_.price)  // No unique tiebreaker - unstable pagination!\n</code></pre></p> <p>4. Match Index Structure: <pre><code>-- If you have this index:\nCREATE INDEX idx_products_category_price_id ON products(category, price, id);\n\n-- Use this seeker to leverage it:\nval seeker = products.toPgTupleSeekerAsc\n  .seek(_.category)  -- Matches index order\n  .seek(_.price)\n  .seek(_.id)\n</code></pre></p>"},{"location":"cookbook/#troubleshooting","title":"Troubleshooting","text":"<p>Compile Error: \"No given instance of type BaseTypedType[Option[String]]\"</p> <pre><code>// You're trying to use a nullable column\nval seeker = users.toPgTupleSeekerAsc\n  .seek(_.email)  // email is Option[String]\n</code></pre> <p>Fix: Use standard <code>SlickSeeker</code> or ensure column is non-nullable in schema.</p> <p>Compile Error: \"value toPgTupleSeekerAsc is not a member\"</p> <pre><code>// You haven't imported the profile API\nval seeker = users.toPgTupleSeekerAsc  // \u274c\n</code></pre> <p>Fix: Import your profile API: <pre><code>import MyPostgresProfile.api._\n</code></pre></p> <p>Runtime Error: \"Syntax error near '&gt;'\"</p> <p>Database doesn't support tuple comparison. Use standard <code>SlickSeeker</code>.</p>"},{"location":"cookbook/#custom-cursor-environments","title":"Custom Cursor Environments","text":"<p>Following are only examples and not meant to copy as-is. Adjust for your use case.</p>"},{"location":"cookbook/#identity-testing","title":"Identity (Testing)","text":"<p>Useful for debugging - no encoding:</p> <pre><code>trait MyProfile extends PostgresProfile \n  with SlickSeekerSupport \n  with PlayJsonSeekerSupport {\n\n  object MyApi extends API with SeekImplicits with JsonSeekerImplicits {\n    override implicit val cursorEnvironment: CursorEnvironment[JsValue] =\n      CursorEnvironment(jsonCursorCodec, IdentityDecorator())\n  }\n\n  override val api: MyApi.type = MyApi\n}\n// Cursor looks like: &gt;[1,\"Alice\"]\n</code></pre>"},{"location":"cookbook/#compression","title":"Compression","text":"<pre><code>import java.io._\nimport java.util.zip._\n\nclass GzipDecorator(inner: CursorDecorator = IdentityDecorator()) \n  extends CursorDecorator {\n\n  override def encode(value: String): String = {\n    val innerEncoded = inner.encode(value)\n    val bytes = innerEncoded.getBytes(StandardCharsets.UTF_8)\n    val out = new ByteArrayOutputStream()\n    val gzip = new GZIPOutputStream(out)\n    gzip.write(bytes)\n    gzip.close()\n    out.toByteArray.map(\"%02x\".format(_)).mkString\n  }\n\n  override def decode(cursor: String): Either[Throwable, String] = {\n    Try {\n      val bytes = cursor.grouped(2).map(Integer.parseInt(_, 16).toByte).toArray\n      val in = new GZIPInputStream(new ByteArrayInputStream(bytes))\n      val result = new String(in.readAllBytes(), StandardCharsets.UTF_8)\n      in.close()\n      result\n    }.toEither.flatMap(inner.decode)\n  }\n}\n\ntrait MyProfile extends PostgresProfile \n  with SlickSeekerSupport \n  with PlayJsonSeekerSupport {\n\n  object MyApi extends API with SeekImplicits with JsonSeekerImplicits {\n    override implicit val cursorEnvironment: CursorEnvironment[JsValue] =\n      CursorEnvironment(jsonCursorCodec, Base64Decorator(GzipDecorator()))\n  }\n\n  override val api: MyApi.type = MyApi\n}\n</code></pre>"},{"location":"cookbook/#hmac-signing-prevent-tampering","title":"HMAC Signing (Prevent Tampering)","text":"<p>Recommended for production - prevents users from crafting malicious cursors:</p> <pre><code>import javax.crypto._\nimport javax.crypto.spec._\n\nclass HMACDecorator(\n  secret: String,\n  inner: CursorDecorator = IdentityDecorator()\n) extends CursorDecorator {\n\n  private def hmacSha256(data: String, key: String): String = {\n    val mac = Mac.getInstance(\"HmacSHA256\")\n    mac.init(new SecretKeySpec(key.getBytes(StandardCharsets.UTF_8), \"HmacSHA256\"))\n    mac.doFinal(data.getBytes(StandardCharsets.UTF_8))\n      .map(\"%02x\".format(_))\n      .mkString\n  }\n\n  override def encode(value: String): String = {\n    val innerEncoded = inner.encode(value)\n    val signature = hmacSha256(innerEncoded, secret)\n    s\"$signature:$innerEncoded\"\n  }\n\n  override def decode(cursor: String): Either[Throwable, String] = {\n    cursor.split(\":\", 2) match {\n      case Array(sig, data) if sig == hmacSha256(data, secret) =&gt;\n        inner.decode(data)\n      case _ =&gt;\n        Left(new IllegalArgumentException(\"Invalid cursor signature\"))\n    }\n  }\n}\n\ntrait MyProfile extends PostgresProfile \n  with SlickSeekerSupport \n  with PlayJsonSeekerSupport {\n\n  object MyApi extends API with SeekImplicits with JsonSeekerImplicits {\n    override implicit val cursorEnvironment: CursorEnvironment[JsValue] =\n      CursorEnvironment(jsonCursorCodec, Base64Decorator(HMACDecorator(\"your-secret-key\")))\n  }\n\n  override val api: MyApi.type = MyApi\n}\n</code></pre>"},{"location":"cookbook/#encryption","title":"Encryption","text":"<p>For sensitive data in cursors:</p> <pre><code>import javax.crypto._\nimport javax.crypto.spec._\n\nclass AESDecorator(\n  key: String,\n  inner: CursorDecorator = IdentityDecorator()\n) extends CursorDecorator {\n\n  private val cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\")\n  private val secretKey = new SecretKeySpec(\n    key.getBytes(StandardCharsets.UTF_8).take(16), \n    \"AES\"\n  )\n\n  override def encode(value: String): String = {\n    val innerEncoded = inner.encode(value)\n    cipher.init(Cipher.ENCRYPT_MODE, secretKey)\n    val encrypted = cipher.doFinal(innerEncoded.getBytes(StandardCharsets.UTF_8))\n    val iv = cipher.getIV\n    (iv ++ encrypted).map(\"%02x\".format(_)).mkString\n  }\n\n  override def decode(cursor: String): Either[Throwable, String] = {\n    Try {\n      val bytes = cursor.grouped(2).map(Integer.parseInt(_, 16).toByte).toArray\n      val iv = bytes.take(16)\n      val encrypted = bytes.drop(16)\n      cipher.init(Cipher.DECRYPT_MODE, secretKey, new IvParameterSpec(iv))\n      val decrypted = cipher.doFinal(encrypted)\n      new String(decrypted, StandardCharsets.UTF_8)\n    }.toEither.flatMap(inner.decode)\n  }\n}\n\ntrait MyProfile extends PostgresProfile \n  with SlickSeekerSupport \n  with PlayJsonSeekerSupport {\n\n  object MyApi extends API with SeekImplicits with JsonSeekerImplicits {\n    override implicit val cursorEnvironment: CursorEnvironment[JsValue] =\n      CursorEnvironment(jsonCursorCodec, Base64Decorator(AESDecorator(\"my-secret-key-16\")))\n  }\n\n  override val api: MyApi.type = MyApi\n}\n</code></pre>"},{"location":"cookbook/#error-handling","title":"Error Handling","text":""},{"location":"cookbook/#invalid-cursors","title":"Invalid Cursors","text":"<pre><code>def safePagenate(\n  seeker: SlickSeeker[_, User, _, _, _],\n  cursor: Option[String],\n  limit: Int\n): Future[Either[String, PaginatedResult[User]]] = {\n\n  Future {\n    db.run(seeker.page(limit, cursor))\n  }.map(Right(_))\n   .recover {\n     case e: IllegalArgumentException =&gt; \n       Left(s\"Invalid cursor: ${e.getMessage}\")\n     case e =&gt;\n       Left(s\"Database error: ${e.getMessage}\")\n   }\n}\n</code></pre>"},{"location":"cookbook/#cursor-expiration","title":"Cursor Expiration","text":"<pre><code>case class ExpiringCursor(\n  values: Seq[JsValue],\n  expiresAt: Long\n)\n\nclass ExpiringCursorCodec extends CursorCodec[JsValue] {\n  def encode(values: Seq[JsValue]): String = {\n    val cursor = ExpiringCursor(\n      values,\n      System.currentTimeMillis() + 3600000  // 1 hour\n    )\n    Json.stringify(Json.toJson(cursor))\n  }\n\n  def decode(cursor: String): Either[String, Seq[JsValue]] = {\n    Try(Json.parse(cursor).as[ExpiringCursor]).toEither\n      .left.map(e =&gt; s\"Invalid cursor: ${e.getMessage}\")\n      .flatMap { c =&gt;\n        if (System.currentTimeMillis() &gt; c.expiresAt) {\n          Left(\"Cursor expired\")\n        } else {\n          Right(c.values)\n        }\n      }\n  }\n}\n\ntrait MyProfile extends PostgresProfile with SlickSeekerSupport {\n  implicit val cursorEnv: CursorEnvironment[JsValue] = \n    CursorEnvironment(ExpiringCursorCodec(), Base64Decorator())\n}\n</code></pre>"},{"location":"cookbook/#testing","title":"Testing","text":""},{"location":"cookbook/#test-pagination-completeness","title":"Test Pagination Completeness","text":"<pre><code>class UserPaginationSpec extends AnyWordSpec {\n  \"paginate through all users\" in {\n    val seeker = users.toSeeker\n      .seek(_.name.asc)\n      .seek(_.id.asc)\n\n    def getAllPages(\n      cursor: Option[String] = None,\n      acc: Seq[User] = Seq.empty\n    ): Future[Seq[User]] = {\n      db.run(seeker.page(10, cursor)).flatMap { page =&gt;\n        val allItems = acc ++ page.items\n        page.nextCursor match {\n          case Some(next) =&gt; getAllPages(Some(next), allItems)\n          case None =&gt; Future.successful(allItems)\n        }\n      }\n    }\n\n    val allPaginated = await(getAllPages())\n    val allDirect = await(db.run(users.result))\n\n    allPaginated should contain theSameElementsInOrderAs allDirect\n  }\n}\n</code></pre>"},{"location":"cookbook/#test-bidirectional-consistency","title":"Test Bidirectional Consistency","text":"<pre><code>\"forward and backward pagination should be consistent\" in {\n  val seeker = users.toSeeker.seek(_.name.asc).seek(_.id.asc)\n\n  // Go forward\n  val p1 = await(db.run(seeker.page(5, None)))\n  val p2 = await(db.run(seeker.page(5, p1.nextCursor)))\n  val p3 = await(db.run(seeker.page(5, p2.nextCursor)))\n\n  // Go backward\n  val back2 = await(db.run(seeker.page(5, p3.prevCursor)))\n  val back1 = await(db.run(seeker.page(5, back2.prevCursor)))\n\n  // Should match\n  back2.items shouldBe p2.items\n  back1.items shouldBe p1.items\n}\n</code></pre>"},{"location":"quickstart/","title":"Quick Start","text":"<p>Get started with Slick Seeker in 5 minutes.</p>"},{"location":"quickstart/#installation","title":"Installation","text":"<p>Add to your <code>build.sbt</code>:</p> <pre><code>libraryDependencies ++= Seq(\n  \"io.github.devnico\" %% \"slick-seeker\" % \"0.4.0\",\n  \"io.github.devnico\" %% \"slick-seeker-play-json\" % \"0.4.0\"  // Optional\n)\n</code></pre>"},{"location":"quickstart/#basic-usage","title":"Basic Usage","text":""},{"location":"quickstart/#step-1-create-your-profile","title":"Step 1: Create Your Profile","text":"<p>Create a custom profile that extends your database profile and mixes in <code>SlickSeekerSupport</code>:</p> <pre><code>import slick.jdbc.PostgresProfile\nimport io.github.devnico.slickseeker.SlickSeekerSupport\nimport io.github.devnico.slickseeker.playjson.PlayJsonSeekerSupport\n\ntrait MyPostgresProfile extends PostgresProfile \n  with SlickSeekerSupport \n  with PlayJsonSeekerSupport {\n\n  object MyApi extends API with SeekImplicits with JsonSeekerImplicits\n\n  override val api: MyApi.type = MyApi\n}\n\nobject MyPostgresProfile extends MyPostgresProfile\n</code></pre> <p>Why? This pattern allows Slick Seeker to work with any JDBC profile (PostgreSQL, MySQL, H2, SQLite, Oracle, etc.) without being tied to a specific database. By defining the cursor environment inside your profile, it's available wherever you import the profile API.</p>"},{"location":"quickstart/#step-2-import-your-profile-api","title":"Step 2: Import Your Profile API","text":"<pre><code>// Import your custom profile API\nimport MyPostgresProfile.api._\n</code></pre> <p>This provides:</p> <ul> <li>All Slick query methods (<code>filter</code>, <code>sortBy</code>, <code>map</code>, etc.)</li> <li>Slick Seeker's <code>.toSeeker</code> extension method</li> <li>All necessary type classes and implicits</li> <li>Your cursor environment</li> </ul>"},{"location":"quickstart/#step-3-define-your-table","title":"Step 3: Define Your Table","text":"<pre><code>case class User(id: Int, name: String, email: String, active: Boolean)\n\nclass Users(tag: Tag) extends Table[User](tag, \"users\") {\n  def id = column[Int](\"id\", O.PrimaryKey, O.AutoInc)\n  def name = column[String](\"name\")\n  def email = column[String](\"email\")\n  def active = column[Boolean](\"active\")\n\n  def * = (id, name, email, active).mapTo[User]\n}\n\nval users = TableQuery[Users]\n</code></pre>"},{"location":"quickstart/#step-4-create-a-seeker","title":"Step 4: Create a Seeker","text":"<pre><code>val seeker = users.toSeeker\n  .seek(_.name.asc)      // Primary sort: name ascending\n  .seek(_.id.asc)        // Tiebreaker: id ascending\n</code></pre>"},{"location":"quickstart/#step-5-paginate","title":"Step 5: Paginate","text":"<pre><code>import scala.concurrent.ExecutionContext.Implicits.global\n\n// First page\nval page1: Future[PaginatedResult[User]] = \n  db.run(seeker.page(limit = 20, cursor = None))\n\n// Next page (use cursor from previous page)\nval page2: Future[PaginatedResult[User]] = \n  page1.flatMap { p1 =&gt;\n    db.run(seeker.page(limit = 20, cursor = p1.nextCursor))\n  }\n\n// Previous page (bidirectional navigation)\nval backToPage1: Future[PaginatedResult[User]] =\n  page2.flatMap { p2 =&gt;\n    db.run(seeker.page(limit = 20, cursor = p2.prevCursor))\n  }\n</code></pre>"},{"location":"quickstart/#paginatedresult","title":"PaginatedResult","text":"<p>The <code>page()</code> method returns a <code>PaginatedResult[T]</code>:</p> <pre><code>case class PaginatedResult[T](\n  total: Int,              // Total number of items\n  items: Seq[T],           // Current page items\n  nextCursor: Option[String],  // Cursor for next page (None if last page)\n  prevCursor: Option[String]   // Cursor for previous page (None if first page)\n)\n</code></pre>"},{"location":"quickstart/#using-with-play-json","title":"Using with Play JSON","text":"<p>For REST APIs, you can serialize <code>PaginatedResult</code> to JSON:</p> <pre><code>import io.github.devnico.slickseeker.playjson._\nimport play.api.libs.json.Json\n\nimplicit val userFormat = Json.format[User]\n\nval result: PaginatedResult[User] = ???\nval json = Json.toJson(result)\n// {\n//   \"total\": 100,\n//   \"items\": [...],\n//   \"nextCursor\": \"eyJkaXJlY3Rpb24iOiJmb3J3YXJkIiwiLi4u\",\n//   \"prevCursor\": null\n// }\n</code></pre>"},{"location":"quickstart/#common-patterns","title":"Common Patterns","text":""},{"location":"quickstart/#sort-by-multiple-columns","title":"Sort by Multiple Columns","text":"<pre><code>val seeker = users.toSeeker\n  .seek(_.active.desc)    // Active users first\n  .seek(_.name.asc)       // Then by name\n  .seek(_.id.asc)         // Tiebreaker\n</code></pre>"},{"location":"quickstart/#handle-nullable-columns","title":"Handle Nullable Columns","text":"<pre><code>case class Person(id: Int, firstName: String, lastName: Option[String])\n\nval seeker = persons.toSeeker\n  .seek(_.lastName.nullsLast.asc)  // NULLs at the end\n  .seek(_.firstName.asc)\n  .seek(_.id.asc)\n</code></pre>"},{"location":"quickstart/#reverse-sort-direction","title":"Reverse Sort Direction","text":"<pre><code>// Sort descending\nval seeker = users.toSeeker\n  .seek(_.name.desc)\n  .seek(_.id.desc)\n\n// Or use seekDirection\nval seeker2 = users.toSeeker\n  .seek(_.name)\n  .seek(_.id)\n  .seekDirection(SortDirection.Desc)\n</code></pre>"},{"location":"quickstart/#postgresql-use-type-safe-tuple-seeker","title":"PostgreSQL? Use Type-Safe Tuple Seeker!","text":"<p>If you're using PostgreSQL and all your seek columns are non-nullable with uniform direction, use <code>SlickPgTupleSeeker</code> for compile-time safety and better performance:</p> <pre><code>// Standard SlickSeeker (works on any database)\nval standardSeeker = users.toSeeker\n  .seek(_.name.asc)\n  .seek(_.id.asc)\n\n// PostgreSQL-optimized with compile-time safety\nval pgSeeker = users.toPgTupleSeekerAsc\n  .seek(_.name)   // No .asc needed - enforced by type\n  .seek(_.id)\n\n// Generates optimized SQL:\n// WHERE (name, id) &gt; (?, ?)\n// vs standard: WHERE (name &gt; ?) OR (name = ? AND id &gt; ?)\n</code></pre> <p>Benefits: - \u2705 Compile-time safety - rejects <code>Option[T]</code> columns at compilation - \u2705 Simpler SQL - single tuple comparison instead of OR clauses - \u2705 Better performance - easier for PostgreSQL to optimize - \u2705 Type-enforced direction - impossible to mix ASC/DESC</p> <p>Use when: - Database is PostgreSQL 8.2+ or H2 in PostgreSQL mode - All columns are non-nullable (no <code>Option[T]</code>) - All columns have same direction (all ASC or all DESC)</p> <p>See Cookbook - PostgreSQL Tuple Optimization for details.</p>"},{"location":"quickstart/#quick-reference","title":"Quick Reference","text":""},{"location":"quickstart/#choose-your-seeker","title":"Choose Your Seeker","text":"Feature Standard <code>SlickSeeker</code> <code>SlickPgTupleSeeker</code> Databases All (PostgreSQL, MySQL, H2, SQLite, etc.) PostgreSQL 8.2+, H2 (PG mode) Nullable columns \u2705 Yes \u274c No - compile error Mixed directions \u2705 Yes \u274c No - type enforced Type safety Runtime Compile-time SQL generation OR-based clauses Tuple comparison Performance Good Better (PostgreSQL)"},{"location":"quickstart/#api-quick-reference","title":"API Quick Reference","text":"<pre><code>// Standard seeker\nusers.toSeeker\n  .seek(_.col.asc)           // Ascending\n  .seek(_.col.desc)          // Descending\n  .seek(_.col.nullsLast.asc) // Nulls handling\n  .seekDirection(...)        // Batch direction change\n\n// PostgreSQL tuple seeker (type-safe)\nusers.toPgTupleSeekerAsc     // All columns ASC\n  .seek(_.col)               // No .asc/.desc needed\n\nusers.toPgTupleSeekerDesc    // All columns DESC\n  .seek(_.col)\n\n// Pagination (same for both)\nseeker.page(limit = 20, cursor = None)           // First page\nseeker.page(limit = 20, cursor = Some(\"...\"))    // Next/prev page\n</code></pre>"},{"location":"quickstart/#whats-next","title":"What's Next?","text":"<ul> <li>Core Concepts - Deep dive into cursor pagination and decorators</li> <li>Cookbook - Real-world examples and PostgreSQL optimization</li> </ul>"}]}