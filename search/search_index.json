{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Slick Seeker","text":"<p>Type-safe, high-performance cursor-based pagination for Slick 3.5+.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Keyset Pagination - O(1) performance regardless of page depth</li> <li>Bidirectional - Navigate forward and backward through result sets</li> <li>Type-Safe - Compile-time verification of cursor/column matching</li> <li>Profile Agnostic - Works with any Slick JDBC profile (PostgreSQL, MySQL, H2, SQLite, Oracle, etc.)</li> <li>Flexible Ordering - Support for nulls first/last, custom enum orders</li> <li>Modular - Core + optional Play JSON integration</li> <li>Composable - Chain decorators for Base64, compression, encryption</li> </ul>"},{"location":"#why-cursor-based-pagination","title":"Why Cursor-Based Pagination?","text":"<p>Traditional offset-based pagination (<code>OFFSET</code> + <code>LIMIT</code>) has serious performance issues:</p> <pre><code>-- Page 1000: Database must scan and skip 19,900 rows!\nSELECT * FROM users ORDER BY name LIMIT 100 OFFSET 19900;\n</code></pre> <p>Problems: - Slow for deep pages (O(n) where n = offset) - Unstable with concurrent writes (items shift between pages) - Memory intensive for large offsets</p> <p>Cursor-based pagination (keyset pagination) solves this:</p> <pre><code>-- Any page: Fast index-based lookup!\nSELECT * FROM users\nWHERE name &gt; 'last_name' OR (name = 'last_name' AND id &gt; last_id)\nORDER BY name, id \nLIMIT 100;\n</code></pre> <p>Benefits: - Constant O(1) performance for any page - Stable with concurrent writes - Efficient index usage</p>"},{"location":"#installation","title":"Installation","text":"<p>Add to your <code>build.sbt</code>:</p> <pre><code>libraryDependencies ++= Seq(\n  \"io.github.devnico\" %% \"slick-seeker\" % \"0.1.0\",\n  \"io.github.devnico\" %% \"slick-seeker-play-json\" % \"0.1.0\"  // Optional, but you need some kind of cursor encoder\n)\n</code></pre>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>// Step 1: Create a custom profile\nimport slick.jdbc.PostgresProfile\nimport io.github.devnico.slickseeker.SlickSeekerSupport\nimport io.github.devnico.slickseeker.playjson.PlayJsonSeekerSupport\n\ntrait MyPostgresProfile extends PostgresProfile \n  with SlickSeekerSupport \n  with PlayJsonSeekerSupport {\n\n  object MyApi extends API with SeekImplicits with JsonSeekerImplicits\n  override val api: MyApi.type = MyApi\n}\n\nobject MyPostgresProfile extends MyPostgresProfile\n\n// Step 2: Import your profile API\nimport MyPostgresProfile.api._\n\n// Step 3: Define your table\ncase class User(id: Int, name: String, email: String)\n\nclass Users(tag: Tag) extends Table[User](tag, \"users\") {\n  def id = column[Int](\"id\", O.PrimaryKey, O.AutoInc)\n  def name = column[String](\"name\")\n  def email = column[String](\"email\")\n  def * = (id, name, email).mapTo[User]\n}\n\nval users = TableQuery[Users]\n\n// Create a seeker\nval seeker = users.toSeeker\n  .seek(_.name.asc)      // Primary sort\n  .seek(_.id.asc)        // Tiebreaker\n\n// Paginate!\nval page1 = db.run(seeker.page(limit = 20, cursor = None))\n// PaginatedResult(total=100, items=[...], nextCursor=Some(\"...\"), prevCursor=None)\n\nval page2 = db.run(seeker.page(limit = 20, cursor = page1.nextCursor))\n// Continue pagination...\n</code></pre>"},{"location":"#learn-more","title":"Learn More","text":"<ul> <li>Quick Start - Get up and running in 5 minutes</li> <li>Core Concepts - Understand cursor pagination and decorators</li> <li>Cookbook - Real-world examples and patterns</li> </ul>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Scala 2.13.14+, 3.3.4+, 3.5.2+</li> <li>Slick 3.5.0+</li> <li>Your Slick profile API must be imported before slick-seeker</li> </ul>"},{"location":"#license","title":"License","text":"<p>Apache License 2.0 - Copyright \u00a9 2025 Nicolas Schlecker</p>"},{"location":"concepts/","title":"Core Concepts","text":""},{"location":"concepts/#cursor-based-pagination","title":"Cursor-Based Pagination","text":"<p>Slick Seeker implements keyset pagination, which uses the values from the last row as a cursor to find the next page.</p>"},{"location":"concepts/#how-it-works","title":"How It Works","text":"<p>Instead of using <code>OFFSET</code>:</p> <pre><code>-- Slow for deep pages\nSELECT * FROM users ORDER BY name LIMIT 20 OFFSET 1000;\n</code></pre> <p>We use the last row's values:</p> <pre><code>-- Fast for any page\nSELECT * FROM users \nWHERE name &gt; 'last_name' OR (name = 'last_name' AND id &gt; last_id)\nORDER BY name, id \nLIMIT 20;\n</code></pre>"},{"location":"concepts/#seek","title":"seek()","text":"<p>Use <code>seek()</code> for direct column references.</p> <pre><code>// Direct columns - automatic extraction\nval seeker = users.toSeeker\n  .seek(_.name.asc)\n  .seek(_.id.asc)\n</code></pre> <p>Works with: - Table columns: <code>_.name</code>, <code>_.email</code> - Tuple fields: <code>_._1</code>, <code>_._2</code> - Nested tuples: <code>_._1._2</code> - Any computed column: <code>_.name.toLowerCase</code></p> <p>The SQL looks like:</p> <pre><code>SELECT t.*, t.name, t.id  -- Cursor columns added automatically\nFROM users t\nWHERE t.name &gt; ? OR (t.name = ? AND t.id &gt; ?)\nORDER BY t.name ASC, t.id ASC\nLIMIT 20\n</code></pre>"},{"location":"concepts/#null-handling","title":"Null Handling","text":"<p>Slick Seeker supports explicit null ordering:</p> <pre><code>// Nulls last (default for ASC)\n.seek(_.lastName.asc)\n.seek(_.lastName.nullsLast.asc)  // Explicit\n\n// Nulls first\n.seek(_.lastName.nullsFirst.asc)\n</code></pre> <p>Direction affects default null ordering:</p> <pre><code>// ASC: nulls last by default\n.seek(_.lastName)\n.seekDirection(SortDirection.Asc)\n\n// DESC: nulls first by default\n.seek(_.lastName)\n.seekDirection(SortDirection.Desc)\n</code></pre>"},{"location":"concepts/#complex-null-handling","title":"Complex Null Handling","text":"<pre><code>case class Person(\n  id: Int,\n  firstName: String,\n  middleName: Option[String],\n  lastName: Option[String]\n)\n\n// Sort: lastName (nulls last), middleName (nulls first), firstName, id\nval seeker = persons.toSeeker\n  .seek(_.lastName.nullsLast.asc)\n  .seek(_.middleName.nullsFirst.asc)\n  .seek(_.firstName.asc)\n  .seek(_.id.asc)\n</code></pre>"},{"location":"concepts/#custom-sort-orders-enumsadts","title":"Custom Sort Orders (Enums/ADTs)","text":"<p>For enums or sealed traits, define a custom sort order:</p> Scala 3Scala 2 <pre><code>enum Status {\n  case Pending, Active, Completed, Archived\n}\n\n// Define the order\ngiven SeekOrder[Status] = SeekOrder(IndexedSeq(\n  Status.Pending,\n  Status.Active,\n  Status.Completed,\n  Status.Archived\n))\n\n// Use it\nval seeker = tasks.toSeeker\n  .seek(_.status.asc)  // Uses custom order\n  .seek(_.id.asc)\n</code></pre> <pre><code>sealed trait Status\nobject Status {\n  case object Pending extends Status\n  case object Active extends Status\n  case object Completed extends Status\n  case object Archived extends Status\n}\n\n// Define the order\nimplicit val statusOrder: SeekOrder[Status] = SeekOrder(IndexedSeq(\n  Status.Pending,\n  Status.Active,\n  Status.Completed,\n  Status.Archived\n))\n\n// Use it\nval seeker = tasks.toSeeker\n  .seek(_.status.asc)  // Uses custom order\n  .seek(_.id.asc)\n</code></pre> <p>This converts enum values to integers in SQL:</p> <pre><code>ORDER BY \n  CASE \n    WHEN status = 'Pending' THEN 0\n    WHEN status = 'Active' THEN 1\n    WHEN status = 'Completed' THEN 2\n    WHEN status = 'Archived' THEN 3\n  END ASC\n</code></pre>"},{"location":"concepts/#bidirectional-pagination","title":"Bidirectional Pagination","text":"<p>Slick Seeker supports both forward and backward navigation:</p> <pre><code>// Forward\nval page2 = seeker.page(limit = 20, cursor = page1.nextCursor)\n\n// Backward\nval backToPage1 = seeker.page(limit = 20, cursor = page2.prevCursor)\n</code></pre>"},{"location":"concepts/#how-it-works_1","title":"How It Works","text":"<p>Cursors encode direction: - Forward: <code>&gt;</code> prefix - Backward: <code>&lt;</code> prefix</p> <p>For backward pagination: 1. Sort order is reversed 2. Results are retrieved 3. Results are reversed back to original order</p> <p>This ensures consistent ordering regardless of direction.</p>"},{"location":"concepts/#cursor-environment","title":"Cursor Environment","text":"<p>The cursor environment controls how cursors are encoded. Define it inside your profile:</p> <pre><code>import io.github.devnico.slickseeker.playjson.PlayJsonSeekerSupport\n\ntrait MyPostgresProfile extends PostgresProfile \n  with SlickSeekerSupport \n  with PlayJsonSeekerSupport {\n  object MyApi extends API with SeekImplicits with JsonSeekerImplicits\n  override val api: MyApi.type = MyApi\n}\n</code></pre> <p>Components: - Codec: Serializes values (e.g., JSON) - Decorator: Transforms final string (e.g., Base64)</p>"},{"location":"concepts/#decorators","title":"Decorators","text":"<p>Decorators transform cursor strings. Chain them for multiple transformations:</p> <pre><code>trait MyProfile extends PostgresProfile \n  with SlickSeekerSupport \n  with PlayJsonSeekerSupport {\n\n  object MyApi extends API with SeekImplicits with JsonSeekerImplicits {\n    // Override with custom decorator\n    override implicit val cursorEnvironment: CursorEnvironment[JsValue] = \n      CursorEnvironment(jsonCursorCodec, IdentityDecorator())\n  }\n\n  override val api: MyApi.type = MyApi\n}\n</code></pre>"},{"location":"concepts/#custom-decorator","title":"Custom Decorator","text":"<pre><code>class HexDecorator(inner: CursorDecorator = IdentityDecorator()) \n  extends CursorDecorator {\n\n  override def encode(value: String): String = {\n    val innerEncoded = inner.encode(value)\n    innerEncoded.getBytes.map(\"%02x\".format(_)).mkString\n  }\n\n  override def decode(cursor: String): Either[Throwable, String] = {\n    Try {\n      val bytes = cursor.grouped(2).map(Integer.parseInt(_, 16).toByte).toArray\n      new String(bytes)\n    }.toEither.flatMap(inner.decode)\n  }\n}\n\n// Use it\ntrait MyProfile extends PostgresProfile \n  with SlickSeekerSupport \n  with PlayJsonSeekerSupport {\n\n  object MyApi extends API with SeekImplicits with JsonSeekerImplicits {\n    override implicit val cursorEnvironment: CursorEnvironment[JsValue] =\n      CursorEnvironment(jsonCursorCodec, Base64Decorator(HexDecorator()))\n  }\n\n  override val api: MyApi.type = MyApi\n}\n</code></pre> <p>Decorators are useful for: - Base64 - URL-safe encoding - Compression - Reduce cursor size - Encryption - Hide cursor content - Signing - Prevent tampering</p>"},{"location":"concepts/#tips","title":"Tips","text":""},{"location":"concepts/#1-always-include-a-unique-column","title":"1. Always Include a Unique Column","text":"<pre><code>// BAD: Non-unique sort can miss/duplicate items\n.seek(_.status)\n\n// GOOD: Include unique tiebreaker\n.seek(_.status)\n.seek(_.id)\n</code></pre>"},{"location":"concepts/#2-create-composite-indexes","title":"2. Create Composite Indexes","text":"<pre><code>-- Match your seek columns\nCREATE INDEX idx_users_name_id ON users(name, id);\nCREATE INDEX idx_tasks_status_priority_id ON tasks(status, priority, id);\n</code></pre>"},{"location":"concepts/#3-limit-sort-columns","title":"3. Limit Sort Columns","text":"<p>Each sort column adds to the WHERE clause complexity. Use 2-4 columns typically.</p>"},{"location":"cookbook/","title":"Cookbook","text":"<p>Real-world examples and patterns.</p>"},{"location":"cookbook/#rest-api-endpoint","title":"REST API Endpoint","text":"<pre><code>import io.github.devnico.slickseeker._\nimport play.api.mvc._\nimport play.api.libs.json._\n\n// Import your profile API\nimport MyPostgresProfile.api._\n\nclass UserController @Inject()(\n  cc: ControllerComponents,\n  db: Database\n)(implicit ec: ExecutionContext) extends AbstractController(cc) {\n\n  implicit val userFormat: Format[User] = Json.format[User]\n\n  def list(\n    cursor: Option[String],\n    limit: Option[Int],\n    sort: Option[String]\n  ): Action[AnyContent] = Action.async {\n    val seeker = sort match {\n      case Some(\"name\") =&gt; users.toSeeker.seek(_.name.asc).seek(_.id.asc)\n      case Some(\"email\") =&gt; users.toSeeker.seek(_.email.asc).seek(_.id.asc)\n      case _ =&gt; users.toSeeker.seek(_.id.asc)\n    }\n\n    db.run(seeker.page(limit.getOrElse(20), cursor, maxLimit = 100))\n      .map(result =&gt; Ok(Json.toJson(result)))\n  }\n}\n</code></pre>"},{"location":"cookbook/#filtering-with-pagination","title":"Filtering with Pagination","text":"<pre><code>def searchUsers(\n  nameFilter: Option[String],\n  activeOnly: Boolean,\n  cursor: Option[String],\n  limit: Int\n): Future[PaginatedResult[User]] = {\n\n  val baseQuery = users\n    .filterOpt(nameFilter)(_.name like _)\n    .filterIf(activeOnly)(_.active === true)\n\n  val seeker = baseQuery.toSeeker\n    .seek(_.name.asc)\n    .seek(_.id.asc)\n\n  db.run(seeker.page(limit, cursor))\n}\n</code></pre>"},{"location":"cookbook/#joined-tables","title":"Joined Tables","text":"<pre><code>case class Order(id: Int, userId: Int, total: Double, createdAt: Timestamp)\ncase class User(id: Int, name: String, email: String)\ncase class OrderWithUser(order: Order, userName: String)\n\nval ordersWithUsers = orders\n  .join(users).on(_.userId === _.id)\n  .map { case (o, u) =&gt; (o, u.name) }\n\nval seeker = ordersWithUsers.toSeeker\n  .seek(t =&gt; t._1.createdAt.desc)  // Order by order date\n  .seek(t =&gt; t._1.id.asc)          // Tiebreaker\n  .map { case (order, userName) =&gt; \n    OrderWithUser(order, userName)\n  }\n</code></pre>"},{"location":"cookbook/#aggregated-results","title":"Aggregated Results","text":"<pre><code>case class UserStats(userId: Int, orderCount: Int, totalSpent: Double)\n\nval userStats = orders\n  .groupBy(_.userId)\n  .map { case (userId, orders) =&gt;\n    (userId, orders.length, orders.map(_.total).sum)\n  }\n\nval seeker = userStats.toSeeker\n  .seek(_._3.desc)  // Sort by total spent\n  .seek(_._1.asc)   // Tiebreaker: user ID\n</code></pre>"},{"location":"cookbook/#complex-sorting","title":"Complex Sorting","text":""},{"location":"cookbook/#multi-level-priority","title":"Multi-Level Priority","text":"Scala 3Scala 2 <pre><code>enum Priority {\n  case Critical, High, Normal, Low\n}\n\nenum Status {\n  case Open, InProgress, Completed\n}\n\ngiven SeekOrder[Priority] = SeekOrder(IndexedSeq(\n  Priority.Critical, Priority.High, Priority.Normal, Priority.Low\n))\n\ngiven SeekOrder[Status] = SeekOrder(IndexedSeq(\n  Status.Open, Status.InProgress, Status.Completed\n))\n\ncase class Task(\n  id: Int,\n  title: String,\n  priority: Priority,\n  status: Status,\n  dueDate: Option[Timestamp]\n)\n\nval seeker = tasks.toSeeker\n  .seek(_.priority.asc)           // Critical first\n  .seek(_.status.asc)             // Open first\n  .seek(_.dueDate.nullsLast.asc)  // Due date (overdue first)\n  .seek(_.id.asc)                 // Tiebreaker\n</code></pre> <pre><code>sealed trait Priority\nobject Priority {\n  case object Critical extends Priority\n  case object High extends Priority\n  case object Normal extends Priority\n  case object Low extends Priority\n}\n\nsealed trait Status\nobject Status {\n  case object Open extends Status\n  case object InProgress extends Status\n  case object Completed extends Status\n}\n\nimplicit val priorityOrder: SeekOrder[Priority] = SeekOrder(IndexedSeq(\n  Priority.Critical, Priority.High, Priority.Normal, Priority.Low\n))\n\nimplicit val statusOrder: SeekOrder[Status] = SeekOrder(IndexedSeq(\n  Status.Open, Status.InProgress, Status.Completed\n))\n\ncase class Task(\n  id: Int,\n  title: String,\n  priority: Priority,\n  status: Status,\n  dueDate: Option[Timestamp]\n)\n\nval seeker = tasks.toSeeker\n  .seek(_.priority.asc)           // Critical first\n  .seek(_.status.asc)             // Open first\n  .seek(_.dueDate.nullsLast.asc)  // Due date (overdue first)\n  .seek(_.id.asc)                 // Tiebreaker\n</code></pre>"},{"location":"cookbook/#sorting-simplified","title":"Sorting Simplified","text":""},{"location":"cookbook/#basic-sorting","title":"Basic Sorting","text":"<pre><code>val seeker = persons.toSeeker\n  .seek(_.lastName.asc)\n  .seek(_.firstName.asc)\n  .seek(_.id.asc)\n</code></pre>"},{"location":"cookbook/#custom-cursor-environments","title":"Custom Cursor Environments","text":""},{"location":"cookbook/#identity-testing","title":"Identity (Testing)","text":"<p>Useful for debugging - no encoding:</p> <pre><code>trait MyProfile extends PostgresProfile \n  with SlickSeekerSupport \n  with PlayJsonSeekerSupport {\n\n  object MyApi extends API with SeekImplicits with JsonSeekerImplicits {\n    override implicit val cursorEnvironment: CursorEnvironment[JsValue] =\n      CursorEnvironment(jsonCursorCodec, IdentityDecorator())\n  }\n\n  override val api: MyApi.type = MyApi\n}\n// Cursor looks like: &gt;[1,\"Alice\"]\n</code></pre>"},{"location":"cookbook/#compression","title":"Compression","text":"<pre><code>import java.io._\nimport java.util.zip._\n\nclass GzipDecorator(inner: CursorDecorator = IdentityDecorator()) \n  extends CursorDecorator {\n\n  override def encode(value: String): String = {\n    val innerEncoded = inner.encode(value)\n    val bytes = innerEncoded.getBytes(StandardCharsets.UTF_8)\n    val out = new ByteArrayOutputStream()\n    val gzip = new GZIPOutputStream(out)\n    gzip.write(bytes)\n    gzip.close()\n    out.toByteArray.map(\"%02x\".format(_)).mkString\n  }\n\n  override def decode(cursor: String): Either[Throwable, String] = {\n    Try {\n      val bytes = cursor.grouped(2).map(Integer.parseInt(_, 16).toByte).toArray\n      val in = new GZIPInputStream(new ByteArrayInputStream(bytes))\n      val result = new String(in.readAllBytes(), StandardCharsets.UTF_8)\n      in.close()\n      result\n    }.toEither.flatMap(inner.decode)\n  }\n}\n\ntrait MyProfile extends PostgresProfile \n  with SlickSeekerSupport \n  with PlayJsonSeekerSupport {\n\n  object MyApi extends API with SeekImplicits with JsonSeekerImplicits {\n    override implicit val cursorEnvironment: CursorEnvironment[JsValue] =\n      CursorEnvironment(jsonCursorCodec, Base64Decorator(GzipDecorator()))\n  }\n\n  override val api: MyApi.type = MyApi\n}\n</code></pre>"},{"location":"cookbook/#hmac-signing-prevent-tampering","title":"HMAC Signing (Prevent Tampering)","text":"<p>Recommended for production - prevents users from crafting malicious cursors:</p> <pre><code>import javax.crypto._\nimport javax.crypto.spec._\n\nclass HMACDecorator(\n  secret: String,\n  inner: CursorDecorator = IdentityDecorator()\n) extends CursorDecorator {\n\n  private def hmacSha256(data: String, key: String): String = {\n    val mac = Mac.getInstance(\"HmacSHA256\")\n    mac.init(new SecretKeySpec(key.getBytes(StandardCharsets.UTF_8), \"HmacSHA256\"))\n    mac.doFinal(data.getBytes(StandardCharsets.UTF_8))\n      .map(\"%02x\".format(_))\n      .mkString\n  }\n\n  override def encode(value: String): String = {\n    val innerEncoded = inner.encode(value)\n    val signature = hmacSha256(innerEncoded, secret)\n    s\"$signature:$innerEncoded\"\n  }\n\n  override def decode(cursor: String): Either[Throwable, String] = {\n    cursor.split(\":\", 2) match {\n      case Array(sig, data) if sig == hmacSha256(data, secret) =&gt;\n        inner.decode(data)\n      case _ =&gt;\n        Left(new IllegalArgumentException(\"Invalid cursor signature\"))\n    }\n  }\n}\n\ntrait MyProfile extends PostgresProfile \n  with SlickSeekerSupport \n  with PlayJsonSeekerSupport {\n\n  object MyApi extends API with SeekImplicits with JsonSeekerImplicits {\n    override implicit val cursorEnvironment: CursorEnvironment[JsValue] =\n      CursorEnvironment(jsonCursorCodec, Base64Decorator(HMACDecorator(\"your-secret-key\")))\n  }\n\n  override val api: MyApi.type = MyApi\n}\n</code></pre>"},{"location":"cookbook/#encryption","title":"Encryption","text":"<p>For sensitive data in cursors:</p> <pre><code>import javax.crypto._\nimport javax.crypto.spec._\n\nclass AESDecorator(\n  key: String,\n  inner: CursorDecorator = IdentityDecorator()\n) extends CursorDecorator {\n\n  private val cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\")\n  private val secretKey = new SecretKeySpec(\n    key.getBytes(StandardCharsets.UTF_8).take(16), \n    \"AES\"\n  )\n\n  override def encode(value: String): String = {\n    val innerEncoded = inner.encode(value)\n    cipher.init(Cipher.ENCRYPT_MODE, secretKey)\n    val encrypted = cipher.doFinal(innerEncoded.getBytes(StandardCharsets.UTF_8))\n    val iv = cipher.getIV\n    (iv ++ encrypted).map(\"%02x\".format(_)).mkString\n  }\n\n  override def decode(cursor: String): Either[Throwable, String] = {\n    Try {\n      val bytes = cursor.grouped(2).map(Integer.parseInt(_, 16).toByte).toArray\n      val iv = bytes.take(16)\n      val encrypted = bytes.drop(16)\n      cipher.init(Cipher.DECRYPT_MODE, secretKey, new IvParameterSpec(iv))\n      val decrypted = cipher.doFinal(encrypted)\n      new String(decrypted, StandardCharsets.UTF_8)\n    }.toEither.flatMap(inner.decode)\n  }\n}\n\ntrait MyProfile extends PostgresProfile \n  with SlickSeekerSupport \n  with PlayJsonSeekerSupport {\n\n  object MyApi extends API with SeekImplicits with JsonSeekerImplicits {\n    override implicit val cursorEnvironment: CursorEnvironment[JsValue] =\n      CursorEnvironment(jsonCursorCodec, Base64Decorator(AESDecorator(\"my-secret-key-16\")))\n  }\n\n  override val api: MyApi.type = MyApi\n}\n</code></pre>"},{"location":"cookbook/#error-handling","title":"Error Handling","text":""},{"location":"cookbook/#invalid-cursors","title":"Invalid Cursors","text":"<pre><code>def safePagenate(\n  seeker: SlickSeeker[_, User, _, _, _],\n  cursor: Option[String],\n  limit: Int\n): Future[Either[String, PaginatedResult[User]]] = {\n\n  Future {\n    db.run(seeker.page(limit, cursor))\n  }.map(Right(_))\n   .recover {\n     case e: IllegalArgumentException =&gt; \n       Left(s\"Invalid cursor: ${e.getMessage}\")\n     case e =&gt;\n       Left(s\"Database error: ${e.getMessage}\")\n   }\n}\n</code></pre>"},{"location":"cookbook/#cursor-expiration","title":"Cursor Expiration","text":"<pre><code>case class ExpiringCursor(\n  values: Seq[JsValue],\n  expiresAt: Long\n)\n\nclass ExpiringCursorCodec extends CursorCodec[JsValue] {\n  def encode(values: Seq[JsValue]): String = {\n    val cursor = ExpiringCursor(\n      values,\n      System.currentTimeMillis() + 3600000  // 1 hour\n    )\n    Json.stringify(Json.toJson(cursor))\n  }\n\n  def decode(cursor: String): Either[String, Seq[JsValue]] = {\n    Try(Json.parse(cursor).as[ExpiringCursor]).toEither\n      .left.map(e =&gt; s\"Invalid cursor: ${e.getMessage}\")\n      .flatMap { c =&gt;\n        if (System.currentTimeMillis() &gt; c.expiresAt) {\n          Left(\"Cursor expired\")\n        } else {\n          Right(c.values)\n        }\n      }\n  }\n}\n\ntrait MyProfile extends PostgresProfile with SlickSeekerSupport {\n  implicit val cursorEnv: CursorEnvironment[JsValue] = \n    CursorEnvironment(ExpiringCursorCodec(), Base64Decorator())\n}\n</code></pre>"},{"location":"cookbook/#testing","title":"Testing","text":""},{"location":"cookbook/#test-pagination-completeness","title":"Test Pagination Completeness","text":"<pre><code>class UserPaginationSpec extends AnyWordSpec {\n  \"paginate through all users\" in {\n    val seeker = users.toSeeker\n      .seek(_.name.asc)\n      .seek(_.id.asc)\n\n    def getAllPages(\n      cursor: Option[String] = None,\n      acc: Seq[User] = Seq.empty\n    ): Future[Seq[User]] = {\n      db.run(seeker.page(10, cursor)).flatMap { page =&gt;\n        val allItems = acc ++ page.items\n        page.nextCursor match {\n          case Some(next) =&gt; getAllPages(Some(next), allItems)\n          case None =&gt; Future.successful(allItems)\n        }\n      }\n    }\n\n    val allPaginated = await(getAllPages())\n    val allDirect = await(db.run(users.result))\n\n    allPaginated should contain theSameElementsInOrderAs allDirect\n  }\n}\n</code></pre>"},{"location":"cookbook/#test-bidirectional-consistency","title":"Test Bidirectional Consistency","text":"<pre><code>\"forward and backward pagination should be consistent\" in {\n  val seeker = users.toSeeker.seek(_.name.asc).seek(_.id.asc)\n\n  // Go forward\n  val p1 = await(db.run(seeker.page(5, None)))\n  val p2 = await(db.run(seeker.page(5, p1.nextCursor)))\n  val p3 = await(db.run(seeker.page(5, p2.nextCursor)))\n\n  // Go backward\n  val back2 = await(db.run(seeker.page(5, p3.prevCursor)))\n  val back1 = await(db.run(seeker.page(5, back2.prevCursor)))\n\n  // Should match\n  back2.items shouldBe p2.items\n  back1.items shouldBe p1.items\n}\n</code></pre>"},{"location":"quickstart/","title":"Quick Start","text":"<p>Get started with Slick Seeker in 5 minutes.</p>"},{"location":"quickstart/#installation","title":"Installation","text":"<p>Add to your <code>build.sbt</code>:</p> <pre><code>libraryDependencies ++= Seq(\n  \"io.github.devnico\" %% \"slick-seeker\" % \"0.1.0\",\n  \"io.github.devnico\" %% \"slick-seeker-play-json\" % \"0.1.0\"  // Optional\n)\n</code></pre>"},{"location":"quickstart/#basic-usage","title":"Basic Usage","text":""},{"location":"quickstart/#step-1-create-your-profile","title":"Step 1: Create Your Profile","text":"<p>Create a custom profile that extends your database profile and mixes in <code>SlickSeekerSupport</code>:</p> <pre><code>import slick.jdbc.PostgresProfile\nimport io.github.devnico.slickseeker.SlickSeekerSupport\nimport io.github.devnico.slickseeker.playjson.PlayJsonSeekerSupport\n\ntrait MyPostgresProfile extends PostgresProfile \n  with SlickSeekerSupport \n  with PlayJsonSeekerSupport {\n\n  object MyApi extends API with SeekImplicits with JsonSeekerImplicits\n\n  override val api: MyApi.type = MyApi\n}\n\nobject MyPostgresProfile extends MyPostgresProfile\n</code></pre> <p>Why? This pattern allows Slick Seeker to work with any JDBC profile (PostgreSQL, MySQL, H2, SQLite, Oracle, etc.) without being tied to a specific database. By defining the cursor environment inside your profile, it's available wherever you import the profile API.</p>"},{"location":"quickstart/#step-2-import-your-profile-api","title":"Step 2: Import Your Profile API","text":"<pre><code>// Import your custom profile API\nimport MyPostgresProfile.api._\n</code></pre> <p>This provides: - All Slick query methods (<code>filter</code>, <code>sortBy</code>, <code>map</code>, etc.) - Slick Seeker's <code>.toSeeker</code> extension method - All necessary type classes and implicits - Your cursor environment</p>"},{"location":"quickstart/#step-3-define-your-table","title":"Step 3: Define Your Table","text":"<pre><code>case class User(id: Int, name: String, email: String, active: Boolean)\n\nclass Users(tag: Tag) extends Table[User](tag, \"users\") {\n  def id = column[Int](\"id\", O.PrimaryKey, O.AutoInc)\n  def name = column[String](\"name\")\n  def email = column[String](\"email\")\n  def active = column[Boolean](\"active\")\n\n  def * = (id, name, email, active).mapTo[User]\n}\n\nval users = TableQuery[Users]\n</code></pre>"},{"location":"quickstart/#step-4-create-a-seeker","title":"Step 4: Create a Seeker","text":"<pre><code>val seeker = users.toSeeker\n  .seek(_.name.asc)      // Primary sort: name ascending\n  .seek(_.id.asc)        // Tiebreaker: id ascending\n</code></pre>"},{"location":"quickstart/#step-5-paginate","title":"Step 5: Paginate","text":"<pre><code>import scala.concurrent.ExecutionContext.Implicits.global\n\n// First page\nval page1: Future[PaginatedResult[User]] = \n  db.run(seeker.page(limit = 20, cursor = None))\n\n// Next page (use cursor from previous page)\nval page2: Future[PaginatedResult[User]] = \n  page1.flatMap { p1 =&gt;\n    db.run(seeker.page(limit = 20, cursor = p1.nextCursor))\n  }\n\n// Previous page (bidirectional navigation)\nval backToPage1: Future[PaginatedResult[User]] =\n  page2.flatMap { p2 =&gt;\n    db.run(seeker.page(limit = 20, cursor = p2.prevCursor))\n  }\n</code></pre>"},{"location":"quickstart/#paginatedresult","title":"PaginatedResult","text":"<p>The <code>page()</code> method returns a <code>PaginatedResult[T]</code>:</p> <pre><code>case class PaginatedResult[T](\n  total: Int,              // Total number of items\n  items: Seq[T],           // Current page items\n  nextCursor: Option[String],  // Cursor for next page (None if last page)\n  prevCursor: Option[String]   // Cursor for previous page (None if first page)\n)\n</code></pre>"},{"location":"quickstart/#using-with-play-json","title":"Using with Play JSON","text":"<p>For REST APIs, you can serialize <code>PaginatedResult</code> to JSON:</p> <pre><code>import io.github.devnico.slickseeker.playjson._\nimport play.api.libs.json.Json\n\nimplicit val userFormat = Json.format[User]\n\nval result: PaginatedResult[User] = ???\nval json = Json.toJson(result)\n// {\n//   \"total\": 100,\n//   \"items\": [...],\n//   \"nextCursor\": \"eyJkaXJlY3Rpb24iOiJmb3J3YXJkIiwiLi4u\",\n//   \"prevCursor\": null\n// }\n</code></pre>"},{"location":"quickstart/#common-patterns","title":"Common Patterns","text":""},{"location":"quickstart/#sort-by-multiple-columns","title":"Sort by Multiple Columns","text":"<pre><code>val seeker = users.toSeeker\n  .seek(_.active.desc)    // Active users first\n  .seek(_.name.asc)       // Then by name\n  .seek(_.id.asc)         // Tiebreaker\n</code></pre>"},{"location":"quickstart/#handle-nullable-columns","title":"Handle Nullable Columns","text":"<pre><code>case class Person(id: Int, firstName: String, lastName: Option[String])\n\nval seeker = persons.toSeeker\n  .seek(_.lastName.nullsLast.asc)  // NULLs at the end\n  .seek(_.firstName.asc)\n  .seek(_.id.asc)\n</code></pre>"},{"location":"quickstart/#reverse-sort-direction","title":"Reverse Sort Direction","text":"<pre><code>// Sort descending\nval seeker = users.toSeeker\n  .seek(_.name.desc)\n  .seek(_.id.desc)\n\n// Or use seekDirection\nval seeker2 = users.toSeeker\n  .seek(_.name)\n  .seek(_.id)\n  .seekDirection(SortDirection.Desc)\n</code></pre>"},{"location":"quickstart/#whats-next","title":"What's Next?","text":"<ul> <li>Core Concepts - Deep dive into cursor pagination and decorators</li> <li>Cookbook - Real-world examples</li> </ul>"}]}